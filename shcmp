#!/bin/sh

#  Copyright (c) 2018, Avi Halachmi (:avih) https://github.com/avih/shcmp
#
#  Permission to use, copy, modify, and/or distribute this software for any
#  purpose with or without fee is hereby granted, provided that the above
#  copyright notice and this permission notice appear in all copies.
#
#  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
#  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
#  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
#  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
#  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
#  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


if false; then
    # (old) hush: can't parse "subshell function" e.g. -c 'f() (true)'

    # (old) hush: aborts prematurely on -c 'set -e; false || x=1; echo OK'
    # bosh: aborts prematurely on -c 'set -e; f() { false; }; while f; do :; done; echo OK'
    set -e

    # posh: aborts prematurely on -c 'set -u; echo "$@"; echo OK'
    set -u 2>/dev/null || :

    #set -x
fi


# Quote the args for shell re-input. E.g. a=$(SHQ "$@"); eval printf =%s= "$a"
# The output should be eval'ed quoted, else [runs of] IFS will turn to space.
# Note: might touch some variables if not used in a subshell
SHQ() {
    out=
    for v; do
        out=$out\'
        while case $v in *\'*) :;; *) false;; esac; do
            out=$out${v%%\'*}"'\''"
            v=${v#*\'}
        done
        out=$out$v"' "
    done
    printf %s "${out%?}"
}

# ~/.shcmprc can override these functions, which are called at the same context
shcmp_time_init() { . "${SHCMP_TIME_FILE-time.sh}"; TIME_PRINT=0; }
shcmp_time_switch_to() { time_switch_to "$1"; }
shcmp_time_finish() { time_finish; }

# $1: out ok prefix, $2: out err prefix, $3: cmds, $4: trail [,$5..: args]
# Run each of $3 (IFS-separated) with the args (quoted) and trail (unquoted),
# and cluster them by (std) output, including the ok/err output prefix.
# Once done, prints (shell) quoted pairs of args: [<cmds1> <out1> [..]]
# Note: $3 can be functions, commands, etc.
# Note: might touch some variables if not used in a subshell
cluster_outputs() {
    OK=$1 ERR=$2 CMDS=$3 TRAIL=$4; shift 4
    ARGS=$(SHQ "$@"); set --
    [ -z "$DOTIME" ] || shcmp_time_init $CMDS

    for C in $CMDS; do
        [ -z "$DOTIME" ] || shcmp_time_switch_to "$C"

        OUT=$( (eval "$C $ARGS $TRAIL") && echo 0 || echo 1)  # trailing \n's
        case $OUT in *0) OUT=$OK${OUT%?};; *) OUT=$ERR${OUT%?};; esac

        # add "$C" to an existing pair (in "$@") or add a new pair "$C" "$OUT"
        I=1; PA=; FOUND=
        while [ $I -lt $# ]; do
            J=$((I+1)); eval JV=\${$J}
            [ "$JV" = "$OUT" ] && PA=$PA' "${'$I'} $C" "${'$J'}"' && FOUND=1 ||
                                  PA=$PA' "${'$I'}"    "${'$J'}"'
            I=$((I+2))
        done
        [ "$FOUND" ] && eval set -- $PA || set -- "$@" "$C" "$OUT"
    done

    [ -z "$DOTIME" ] || shcmp_time_finish
    SHQ "$@"
}


# output format utils

list_items() {
    printf %s "$*" | sed 's/ /, /g'
}

# args: 1/0 to trim/not-trim output, then arg pairs of: cmd-list common-output
# Note: might touch some variables if not used in a subshell
fmt_out() {
    trim=$1; shift
    while [ $# -gt 0 ]; do
        [ "$trim" = 0 ] && out=$2 || out=$(printf %s "$2")
        printf "= %s:\n%s\n" "$(list_items $1)" "$out"
        shift 2
        [ $# = 0 ] || echo
    done
}


# main

# setup the tested shells
RC=~/.shcmprc  # no tilde expansion in hush at this time, so try also $HOME
[ -e "$RC" ] || RC="$HOME"/.shcmprc

[ -e "$RC" ] && . "$RC" ||
{
    # built in sample shells - if ~/.shcmprc doesn't exist or has non-0 exit
    busybox_ash()  { busybox ash "$@"; }
    busybox_hush() { busybox hush "$@"; }
    bash_posix()   { bash --posix "$@"; }
    mksh_posix()   { mksh -o posix "$@"; }
    yash_posix()   { yash -o posixlycorrect "$@"; }
    foo_shell()    { /path/to/whatever "$@"; }

    shells="sh bash bash_posix busybox_ash busybox_hush dash mksh mksh_posix posh yash yash_posix"

    working_shells=  # keep only the shells that exist/work on this system
    for s in $shells; do
        if $s -c ":" 2>/dev/null; then
            working_shells="$working_shells $s"
        fi
    done
    shells=$working_shells
}

REDIRECT='2>&1' TRIM=1 ALLOW_EMPTY= DOTIME=
while true; do
    case ${1-} in
        --SHELL)  shift; ("$@"); exit
                  ;;
        --NOERR)  REDIRECT=; shift
                  ;;
        --NOTRIM) TRIM=0; shift
                  ;;
        --TIME)   DOTIME=1; shift
                  ;;
        --help|-h)
                  printf %s\\n "Usage: ${0##*/} -h|--help | [--NOERR] [--NOTRIM] [--TIME] arg..."
                  printf %s\\n "       ${0##*/} --SHELL shell [arg...]"
                  printf \\n
                  printf %s\\n "Run different shells with arg... and cluster them by output."
                  printf %s\\n "Note: any unrecognized option, e.g. -c, is considered the begining of arg."
                  printf \\n
                  printf %s\\n "--NOERR  Capture and cluster by stdout only, else (default) stdout+stderr."
                  printf %s\\n "--NOTRIM Don't trim trailing newlines from the outputs display."
                  printf %s\\n "--TIME   Measure durations - expects \$SHCMP_TIME_FILE or time.sh at \$PATH ."
                  printf %s\\n "         See https://github.com/avih/time.sh ."
                  printf %s\\n "--SHELL  Run ${0##*/}-name \`shell' [arg...] without processing or redirections."
                  printf \\n
                  printf %s\\n "Home: https://github.com/avih/shcmp"
                  exit 0
                  ;;
        --)       ALLOW_EMPTY=1; shift; break;
                  ;;
        *)        break
    esac
done

[ $# -gt 0 ] || [ "$ALLOW_EMPTY" ] ||
    { >&2 printf %s\\n "${0##*/}: missing arg. Add \`--' to force. See usage with -h"; exit 1; }

pairs=$(cluster_outputs '' "<error> " "$shells" "$REDIRECT" "$@")
eval fmt_out $TRIM "$pairs"
